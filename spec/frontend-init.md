
### Техническое Задание: Frontend (Lamoda Seller App)

**Цель:** Разработать адаптивный веб-интерфейс для управления товарами селлера. Приложение должно быть быстрым, интуитивно понятным и отлично выглядеть как на десктопе, так и на мобильных устройствах.

**Стек:**
*   **Фреймворк:** React 18+ (с хуками)
*   **Сборщик:** Vite
*   **Язык:** TypeScript
*   **Стилизация:** Tailwind CSS
*   **Роутинг:** `react-router-dom`
*   **Запросы к API:** `axios`
*   **Иконки:** `heroicons` (отлично интегрируется с Tailwind) или `lucide-react`.

---

### План Работы по Этапам (MVP)

Двигаемся от простого к сложному, от "каркаса" к "мясу". Каждый этап — это законченный кусок функциональности.

#### **Этап 0: Подготовка и настройка (1-2 часа)**

*   [ ] **1. Инициализация проекта:**
    *   Создать проект с помощью `npm create vite@latest (папка frontend) -- --template react-ts`.

*   [ ] **2. Установка зависимостей:**
    *   `yarn add -D tailwindcss postcss autoprefixer` и `npx tailwindcss init -p` для настройки Tailwind.
    *   `yarn add react-router-dom axios`.
    *   `yarn add @headlessui/react @heroicons/react` (Headless UI опционально, но очень полезен для кастомных компонентов типа модалок и выпадающих списков).

*   [ ] **3. Настройка Tailwind CSS:**
    *   Настроить `tailwind.config.js` (добавить пути к файлам в `content`).
    *   Создать `src/index.css` и импортировать директивы Tailwind (`@tailwind base; @tailwind components; @tailwind utilities;`).

*   [ ] **4. Создание структуры папок:**
    *   `src/components`: для переиспользуемых UI-компонентов (`Button`, `Card`, `Header` и т.д.).
    *   `src/pages`: для основных экранов приложения (`ProductsListPage`, `ProductDetailPage`).
    *   `src/api`: для моковых данных и клиента API (`mockData.ts`, `apiClient.ts`).
    *   `src/types`: для TypeScript-интерфейсов (`product.ts`, `order.ts`).
    *   `src/hooks`: для кастомных хуков (например, `useApi`).

*   [ ] **5. Создание моковых данных и API-клиента:**
    *   В `src/types/product.ts` описать интерфейс `Product`.
    *   В `src/api/mockData.ts` создать массив моковых продуктов.
    *   В `src/api/apiClient.ts` создать функции `getProducts()` и `getProductById()`, которые возвращают моковые данные через `Promise.resolve()`.

---

#### **Этап 1: Главный экран — Список товаров (3-4 часа)**

Это самый важный экран. Пользователь видит его первым.

*   [ ] **1. Создание Layout-компонента:**
    *   Сделать компонент `Layout.tsx`, который включает в себя `Header`, `Footer` (если нужен) и `Outlet` из `react-router-dom` для отображения контента страниц. Это обеспечит единообразие на всех экранах.
    *   В `Header` разместить логотип и, возможно, иконку профиля.

*   [ ] **2. Создание страницы `ProductsListPage.tsx`:**
    *   С помощью хука `useEffect` и `apiClient.ts` загружать список товаров при монтировании компонента.
    *   Отобразить состояние загрузки (простой `<div>Loading...</div>` или спиннер).
    *   Отобразить состояние ошибки, если данные не пришли.

*   [ ] **3. Создание компонента `ProductCard.tsx`:**
    *   Это карточка для одного товара в списке. Она должна отображать:
        *   Фото товара (`imageUrl`).
        *   Название (`name`).
        *   Цену (`price`).
        *   **Статус (`status`) с цветовой индикацией:**
            *   "На складе" -> зеленый бейдж.
            *   "В обработке" -> желтый бейдж.
            *   "Отклонен" -> красный бейдж.
            *   Используй классы Tailwind: `bg-green-100 text-green-800`, `bg-yellow-100 text-yellow-800` и т.д.
    *   Карточка должна быть ссылкой (`<Link to={`/products/${product.id}`}>`) на страницу деталей товара.

*   [ ] **4. Вёрстка списка:**
    *   На странице `ProductsListPage.tsx` отобразить товары с помощью `.map()` по массиву данных, используя компонент `ProductCard`.
    *   Использовать `grid` или `flex` для адаптивного отображения карточек (например, 3 в ряд на десктопе, 1 в ряд на мобильном).
    *   `className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"`

---

#### **Этап 2: Детализация — Карточка товара (2-3 часа)**

Экран для просмотра и редактирования одного товара.

*   [ ] **1. Создание страницы `ProductDetailPage.tsx`:**
    *   Использовать `useParams` из `react-router-dom`, чтобы получить `id` товара из URL.
    *   Загружать данные одного товара с помощью `apiClient.getProductById(id)`.

*   [ ] **2. Вёрстка страницы:**
    *   Крупное фото товара слева, информация справа (на десктопе). На мобильном — фото сверху, информация снизу.
    *   Отобразить все поля из моковых данных: `name`, `price`, `status`, `description`, `sizes`.
    *   **Ключевой элемент:** Добавить кнопку **"Редактировать"**.

---

#### **Этап 3: Интерактивность — Редактирование товара (3-4 часа)**

Добавляем возможность изменять данные.

*   [ ] **1. Реализация модального окна для редактирования:**
    *   При клике на кнопку "Редактировать" открывать модальное окно (можно использовать Headless UI `Dialog` или написать свой простой компонент).
    *   В модальном окне должны быть поля для редактирования `name` и `price`.

*   [ ] **2. Создание формы:**
    *   Использовать управляемые компоненты (хук `useState`) для полей ввода.
    *   Добавить валидацию (например, цена не может быть отрицательной).

*   [ ] **3. Интеграция с API:**
    *   Подготовить функцию `updateProduct(id, data)` в `apiClient.ts`. Сначала она будет просто обновлять данные в моковом массиве.
    *   При сабмите формы вызывать эту функцию. После успешного обновления — закрывать модальное окно и обновлять данные на странице.

*   [ ] **4. Подключение реального API:**
    *   Как только бэкендер выкатит эндпоинт `PATCH /api/products/:id`, заменить вызов моковой функции на реальный `axios.patch(...)`.

---

#### **Этап 4: Полировка (оставшееся время)**

*   [ ] **1. Фильтрация и поиск:**
    *   На странице `ProductsListPage.tsx` добавить поле для поиска по названию.
    *   Добавить кнопки/выпадающий список для фильтрации по статусу.

*   [ ] **2. Адаптивность и UI:**
    *   Проверить, как все выглядит на разных размерах экранов (используй DevTools).
    *   Добавить плавные переходы (transitions) для ховеров и других интерактивных элементов.

*   [ ] **3. Уведомления (Toasts):**
    *   После успешного сохранения товара показывать уведомление "Товар успешно обновлен!" (например, с помощью `react-hot-toast`).
